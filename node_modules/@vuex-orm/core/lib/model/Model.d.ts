import * as Vuex from 'vuex';
import Database from '../database/Database';
import Record from '../data/Record';
import Item from '../data/Item';
import Collection from '../data/Collection';
import Collections from '../data/Collections';
import State from '../modules/contracts/State';
import * as Attributes from '../attributes';
import Mutator from '../attributes/contracts/Mutator';
import Mutators from '../attributes/contracts/Mutators';
import Query from '../query/Query';
import * as Payloads from '../modules/payloads/Actions';
import Fields from './contracts/Fields';
import ModelState from './contracts/State';
declare type InstanceOf<T> = T extends new (...args: any[]) => infer R ? R : any;
export default class Model {
    /**
     * The name that is going be used as module name in Vuex Store.
     */
    static entity: string;
    /**
     * The primary key to be used for the model.
     */
    static primaryKey: string | string[];
    /**
     * Vuex Store state definition.
     */
    static state: ModelState | (() => ModelState);
    /**
     * The cached attribute fields of the model.
     */
    static cachedFields?: Fields;
    /**
     * The ID value of the store index.
     */
    $id: string | null;
    /**
     * Create a new model instance.
     */
    constructor(record?: Record);
    /**
     * The definition of the fields of the model and its relations.
     */
    static fields(): Fields;
    /**
     * Get the model schema definition by adding additional default fields.
     */
    static getFields(): Fields;
    /**
     * Create an attr attribute. The given value will be used as a default
     * value for the field.
     */
    static attr(value: any, mutator?: Mutator<any>): Attributes.Attr;
    /**
     * Create a string attribute.
     */
    static string(value: any, mutator?: Mutator<string | null>): Attributes.String;
    /**
     * Create a number attribute.
     */
    static number(value: any, mutator?: Mutator<number | null>): Attributes.Number;
    /**
     * Create a boolean attribute.
     */
    static boolean(value: any, mutator?: Mutator<boolean | null>): Attributes.Boolean;
    /**
     * Create an increment attribute. The field with this attribute will
     * automatically increment its value when creating a new record.
     */
    static increment(): Attributes.Increment;
    /**
     * Create a has one relationship.
     */
    static hasOne(related: typeof Model | string, foreignKey: string, localKey?: string): Attributes.HasOne;
    /**
     * Create a belongs to relationship.
     */
    static belongsTo(parent: typeof Model | string, foreignKey: string, ownerKey?: string): Attributes.BelongsTo;
    /**
     * Create a has many relationship.
     */
    static hasMany(related: typeof Model | string, foreignKey: string, localKey?: string): Attributes.HasMany;
    /**
     * Create a has many by relationship.
     */
    static hasManyBy(parent: typeof Model | string, foreignKey: string, ownerKey?: string): Attributes.HasManyBy;
    /**
     * Create a has many through relationship.
     */
    static hasManyThrough(related: typeof Model | string, through: typeof Model | string, firstKey: string, secondKey: string, localKey?: string, secondLocalKey?: string): Attributes.HasManyThrough;
    /**
     * The belongs to many relationship.
     */
    static belongsToMany(related: typeof Model | string, pivot: typeof Model | string, foreignPivotKey: string, relatedPivotKey: string, parentKey?: string, relatedKey?: string): Attributes.BelongsToMany;
    /**
     * Create a morph to relationship.
     */
    static morphTo(id: string, type: string): Attributes.MorphTo;
    /**
     * Create a morph one relationship.
     */
    static morphOne(related: typeof Model | string, id: string, type: string, localKey?: string): Attributes.MorphOne;
    /**
     * Create a morph many relationship.
     */
    static morphMany(related: typeof Model | string, id: string, type: string, localKey?: string): Attributes.MorphMany;
    /**
     * Create a morph to many relationship.
     */
    static morphToMany(related: typeof Model | string, pivot: typeof Model | string, relatedId: string, id: string, type: string, parentKey?: string, relatedKey?: string): Attributes.MorphToMany;
    /**
     * Create a morphed by many relationship.
     */
    static morphedByMany(related: typeof Model | string, pivot: typeof Model | string, relatedId: string, id: string, type: string, parentKey?: string, relatedKey?: string): Attributes.MorphedByMany;
    /**
     * Mutators to mutate matching fields when instantiating the model.
     */
    static mutators(): Mutators;
    /**
     * Get the database instance from the container.
     */
    static database(): Database;
    /**
     * Get the store instance from the container.
     */
    static store(): Vuex.Store<any>;
    /**
     * Create a namespaced method name for Vuex Module from the given
     * method name.
     */
    static namespace(method: string): string;
    /**
     * Call Vuex Getters.
     */
    static getters(method: string): any;
    /**
     * Dispatch Vuex Action.
     */
    static dispatch(method: string, payload?: any): Promise<any>;
    /**
     * Commit Vuex Mutation.
     */
    static commit(callback: (state: State) => void): void;
    /**
     * Get all records.
     */
    static all<T extends typeof Model>(this: T): Collection<InstanceOf<T>>;
    /**
     * Find a record.
     */
    static find<T extends typeof Model>(this: T, id: string | number): Item<InstanceOf<T>>;
    /**
     * Get the record of the given array of ids.
     */
    static findIn<T extends typeof Model>(this: T, idList: Array<number | string>): Collection<InstanceOf<T>>;
    /**
     * Get query instance.
     */
    static query<T extends typeof Model>(this: T): Query<InstanceOf<T>>;
    /**
     * Create new data with all fields filled by default values.
     */
    static new(): Promise<Model>;
    /**
     * Save given data to the store by replacing all existing records in the
     * store. If you want to save data without replacing existing records,
     * use the `insert` method instead.
     */
    static create<T extends typeof Model>(this: T, payload: Payloads.Create): Promise<Collections<InstanceOf<T>>>;
    /**
     * Insert records.
     */
    static insert<T extends typeof Model>(this: T, payload: Payloads.Insert): Promise<Collections<InstanceOf<T>>>;
    /**
     * Update records.
     */
    static update<T extends typeof Model>(this: T, payload: Payloads.Update): Promise<Collections<InstanceOf<T>>>;
    /**
     * Insert or update records.
     */
    static insertOrUpdate<T extends typeof Model>(this: T, payload: Payloads.InsertOrUpdate): Promise<Collections<InstanceOf<T>>>;
    /**
     * Delete records that matches the given condition.
     */
    static delete<T extends typeof Model>(this: T, payload: Payloads.Delete): Promise<Item<InstanceOf<T>> | Collection<InstanceOf<T>>>;
    /**
     * Delete all records.
     */
    static deleteAll(): Promise<void>;
    /**
     * Get the value of the primary key.
     */
    static id(record: any): any;
    /**
     * Get local key to pass to the attributes.
     */
    static localKey(key?: string): string;
    /**
     * Get a model from the container.
     */
    static relation(model: typeof Model | string): typeof Model;
    /**
     * Get the attribute class for the given attribute name.
     */
    static getAttributeClass(name: string): typeof Attributes.Attribute;
    /**
     * Get all of the fields that matches the given attribute name.
     */
    static getFieldsByAttribute(name: string): {
        [key: string]: Attributes.Attribute;
    };
    /**
     * Get all `increment` fields from the schema.
     */
    static getIncrementFields(): {
        [key: string]: Attributes.Increment;
    };
    /**
     * Check if fields contains the `increment` field type.
     */
    static hasIncrementFields(): boolean;
    /**
     * Get all `belongsToMany` fields from the schema.
     */
    static pivotFields(): {
        [key: string]: Attributes.BelongsToMany | Attributes.MorphToMany | Attributes.MorphedByMany;
    }[];
    /**
     * Check if fields contains the `belongsToMany` field type.
     */
    static hasPivotFields(): boolean;
    /**
     * Fill any missing fields in the given record with the default value defined
     * in the model schema.
     */
    static hydrate(record?: Record): Record;
    /**
     * Get the constructor of this model.
     */
    $self(): typeof Model;
    /**
     * The definition of the fields of the model and its relations.
     */
    $fields(): Fields;
    /**
     * Get the store instance from the container.
     */
    $store(): Vuex.Store<any>;
    /**
     * Create a namespaced method name for Vuex Module from the given
     * method name.
     */
    $namespace(method: string): string;
    /**
     * Call Vuex Getetrs.
     */
    $getters(method: string): any;
    /**
     * Dispatch Vuex Action.
     */
    $dispatch(method: string, payload?: any): Promise<any>;
    /**
     * Get all records.
     */
    $all<T extends Model>(this: T): Collection<T>;
    /**
     * Find a record.
     */
    $find<T extends Model>(this: T, id: string | number): Item<T>;
    /**
     * Find record of the given array of ids.
     */
    $findIn<T extends Model>(this: T, idList: Array<number | string>): Collection<T>;
    /**
     * Get query instance.
     */
    $query(): Query;
    /**
     * Create records.
     */
    $create<T extends Model>(this: T, payload: Payloads.Create): Promise<Collections<T>>;
    /**
     * Create records.
     */
    $insert<T extends Model>(this: T, payload: Payloads.Insert): Promise<Collections<T>>;
    /**
     * Update records.
     */
    $update<T extends Model>(this: T, payload: Payloads.Update): Promise<Collections<T>>;
    /**
     * Insert or update records.
     */
    $insertOrUpdate<T extends Model>(this: T, payload: Payloads.InsertOrUpdate): Promise<Collections<T>>;
    /**
     * Save record.
     */
    $save<T extends Model>(this: T): Promise<Item<T>>;
    /**
     * Delete records that matches the given condition.
     */
    $delete<T extends Model>(this: T, condition?: Payloads.Delete): Promise<Item<T> | Collection<T>>;
    /**
     * Delete all records.
     */
    $deleteAll(): Promise<void>;
    /**
     * Fill the model instance with the given record. If no record were passed,
     * or if the record has any missing fields, each value of the fields will
     * be filled with its default value defined at model fields definition.
     */
    $fill(record?: Record): void;
    /**
     * Serialize field values into json.
     */
    $toJson(): Record;
    /**
     * This method is used by Nuxt server-side rendering. It will prevent
     * `non-POJO` warning when using Vuex ORM with Nuxt universal mode.
     * The method is not meant to be used publicly by a user.
     *
     * See https://github.com/vuex-orm/vuex-orm/issues/255 for more detail.
     */
    toJSON(): Record;
}
export {};
