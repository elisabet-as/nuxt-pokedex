import * as tslib_1 from "tslib";
import Utils from '../support/Utils';
import Container from '../container/Container';
import Model from '../model/Model';
import Processor from './processors/Processor';
import Filter from './filters/Filter';
import Loader from './loaders/Loader';
import Rollcaller from './rollcallers/Rollcaller';
import Hook from './hooks/Hook';
var Query = /** @class */ (function () {
    /**
     * Create a new Query instance.
     */
    function Query(state, entity) {
        /**
         * Primary key ids to filter records by. It is used for filtering records
         * direct key lookup when a user is trying to fetch records by its
         * primary key.
         *
         * It should not be used if there is a logic which prevents index usage, for
         * example, an "or" condition which already requires a full scan of records.
         */
        this.idFilter = null;
        /**
         * Whether to use `idFilter` key lookup. True if there is a logic which
         * prevents index usage, for example, an "or" condition which already
         * requires full scan.
         */
        this.cancelIdFilter = false;
        /**
         * Primary key ids to filter joined records. It is used for filtering
         * records direct key lookup. It should not be cancelled, because it
         * is free from the effects of normal where methods.
         */
        this.joinedIdFilter = null;
        /**
         * The where constraints for the query.
         */
        this.wheres = [];
        /**
         * The has constraints for the query.
         */
        this.have = [];
        /**
         * The orders of the query result.
         */
        this.orders = [];
        /**
         * Number of results to skip.
         */
        this.offsetNumber = 0;
        /**
         * Maximum number of records to return.
         *
         * We use polyfill of `Number.MAX_SAFE_INTEGER` for IE11 here.
         */
        this.limitNumber = Math.pow(2, 53) - 1;
        /**
         * The relationships that should be eager loaded with the result.
         */
        this.load = {};
        this.rootState = state;
        this.state = state[entity];
        this.entity = entity;
        this.model = this.getModel(entity);
        this.module = this.getModule(entity);
        this.hook = new Hook(this);
    }
    /**
     * Get the database from the container.
     */
    Query.database = function () {
        return Container.database;
    };
    /**
     * Get model of given name from the container.
     */
    Query.getModel = function (name) {
        return this.database().model(name);
    };
    /**
     * Get all models from the container.
     */
    Query.getModels = function () {
        return this.database().models();
    };
    /**
     * Get module of given name from the container.
     */
    Query.getModule = function (name) {
        return this.database().module(name);
    };
    /**
     * Get all modules from the container.
     */
    Query.getModules = function () {
        return this.database().modules();
    };
    /**
     * Delete all records from the state.
     */
    Query.deleteAll = function (state) {
        var _this = this;
        var models = this.getModels();
        Utils.forOwn(models, function (_model, name) {
            state[name] && (new _this(state, name)).deleteAll();
        });
    };
    /**
     * Register a callback. It Returns unique ID for registered callback.
     */
    Query.on = function (on, callback, once) {
        return Hook.on(on, callback, once);
    };
    /**
     * Remove hook registration.
     */
    Query.off = function (uid) {
        return Hook.off(uid);
    };
    /**
     * Get query class.
     */
    Query.prototype.self = function () {
        return this.constructor;
    };
    /**
     * Create a new query instance.
     */
    Query.prototype.newQuery = function (entity) {
        entity = entity || this.entity;
        return (new Query(this.rootState, entity));
    };
    /**
     * Get the database from the container.
     */
    Query.prototype.database = function () {
        return this.self().database();
    };
    /**
     * Get model of given name from the container.
     */
    Query.prototype.getModel = function (name) {
        var entity = name || this.entity;
        return this.self().getModel(entity);
    };
    /**
     * Get all models from the container.
     */
    Query.prototype.getModels = function () {
        return this.self().getModels();
    };
    /**
     * Get module of given name from the container.
     */
    Query.prototype.getModule = function (name) {
        var entity = name || this.entity;
        return this.self().getModule(entity);
    };
    /**
     * Get all modules from the container.
     */
    Query.prototype.getModules = function () {
        return this.self().getModules();
    };
    /**
     * Returns all record of the query chain result. This method is alias
     * of the `get` method.
     */
    Query.prototype.all = function () {
        return this.get();
    };
    /**
     * Get the record of the given id.
     */
    Query.prototype.find = function (id) {
        return this.item(this.state.data[id]); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Get the record of the given array of ids.
     */
    Query.prototype.findIn = function (idList) {
        var _this = this;
        return idList.map(function (id) { return _this.state.data[id]; }).filter(function (item) { return item; }); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Returns all record of the query chain result.
     */
    Query.prototype.get = function () {
        var records = this.select();
        return this.collect(records); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Returns the first record of the query chain result.
     */
    Query.prototype.first = function () {
        var records = this.select();
        return this.item(records[0]); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Returns the last single record of the query chain result.
     */
    Query.prototype.last = function () {
        var records = this.select();
        return this.item(records[records.length - 1]); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Add a and where clause to the query.
     */
    Query.prototype.where = function (field, value) {
        if (this.isIdfilterable(field)) {
            this.setIdFilter(value);
        }
        this.wheres.push({ field: field, value: value, boolean: 'and' });
        return this;
    };
    /**
     * Add a or where clause to the query.
     */
    Query.prototype.orWhere = function (field, value) {
        // Cacncel id filter usage, since "or" needs full scan.
        this.cancelIdFilter = true;
        this.wheres.push({ field: field, value: value, boolean: 'or' });
        return this;
    };
    /**
     * Filter records by their primary key.
     */
    Query.prototype.whereId = function (value) {
        return this.where(this.model.primaryKey, value);
    };
    /**
     * Filter records by their primary keys.
     */
    Query.prototype.whereIdIn = function (values) {
        return this.where(this.model.primaryKey, values);
    };
    /**
     * Fast comparison for foreign keys. If the foreign key is the primary key,
     * it uses object lookup, fallback normal where otherwise.
     *
     * Why separate `whereFk` instead of just `where`? Additional logic needed
     * for the distinction between where and orWhere in normal queries, but
     * Fk lookups are always "and" type.
     */
    Query.prototype.whereFk = function (field, value) {
        var values = Array.isArray(value) ? value : [value];
        // If lookup filed is the primary key. Initialize or get intersection,
        // because boolean and could have a condition such as
        // `whereId(1).whereId(2).get()`.
        if (field === this.model.primaryKey) {
            this.setJoinedIdFilter(values);
            return this;
        }
        // Else fallback to normal where.
        this.where(field, values);
        return this;
    };
    /**
     * Check whether the given field and value combination is filterable through
     * primary key direct look up.
     */
    Query.prototype.isIdfilterable = function (field) {
        return field === this.model.primaryKey && !this.cancelIdFilter;
    };
    /**
     * Set id filter for the given where condition.
     */
    Query.prototype.setIdFilter = function (value) {
        var _this = this;
        var values = Array.isArray(value) ? value : [value];
        // Initialize or get intersection, because boolean and could have a
        // condition such as `whereIdIn([1,2,3]).whereIdIn([1,2]).get()`.
        if (this.idFilter === null) {
            this.idFilter = new Set(values);
            return;
        }
        this.idFilter = new Set(values.filter(function (v) { return _this.idFilter.has(v); }));
    };
    /**
     * Set joined id filter for the given where condition.
     */
    Query.prototype.setJoinedIdFilter = function (values) {
        var _this = this;
        // Initialize or get intersection, because boolean and could have a
        // condition such as `whereId(1).whereId(2).get()`.
        if (this.joinedIdFilter === null) {
            this.joinedIdFilter = new Set(values);
            return;
        }
        this.joinedIdFilter = new Set(values.filter(function (v) { return _this.joinedIdFilter.has(v); }));
    };
    /**
     * Add an order to the query.
     */
    Query.prototype.orderBy = function (field, direction) {
        if (direction === void 0) { direction = 'asc'; }
        this.orders.push({ field: field, direction: direction });
        return this;
    };
    /**
     * Add an offset to the query.
     */
    Query.prototype.offset = function (offset) {
        this.offsetNumber = offset;
        return this;
    };
    /**
     * Add limit to the query.
     */
    Query.prototype.limit = function (limit) {
        this.limitNumber = limit;
        return this;
    };
    /**
     * Set the relationships that should be loaded.
     */
    Query.prototype.with = function (name, constraint) {
        if (constraint === void 0) { constraint = null; }
        Loader.with(this, name, constraint);
        return this;
    };
    /**
     * Query all relations.
     */
    Query.prototype.withAll = function () {
        Loader.withAll(this);
        return this;
    };
    /**
     * Query all relations recursively.
     */
    Query.prototype.withAllRecursive = function (depth) {
        if (depth === void 0) { depth = 3; }
        Loader.withAllRecursive(this, depth);
        return this;
    };
    /**
     * Set where constraint based on relationship existence.
     */
    Query.prototype.has = function (relation, operator, count) {
        Rollcaller.has(this, relation, operator, count);
        return this;
    };
    /**
     * Set where constraint based on relationship absence.
     */
    Query.prototype.hasNot = function (relation, operator, count) {
        Rollcaller.hasNot(this, relation, operator, count);
        return this;
    };
    /**
     * Add where has condition.
     */
    Query.prototype.whereHas = function (relation, constraint) {
        Rollcaller.whereHas(this, relation, constraint);
        return this;
    };
    /**
     * Add where has not condition.
     */
    Query.prototype.whereHasNot = function (relation, constraint) {
        Rollcaller.whereHasNot(this, relation, constraint);
        return this;
    };
    /**
     * Get all records from the state and convert them into the array. It will
     * check if the record is an instance of Model and if not, it will
     * instantiate before returning them.
     *
     * This is needed to support SSR, that when the state is hydrated at server
     * side, it will be converted to the plain record at the client side.
     */
    Query.prototype.records = function () {
        var _this = this;
        this.finalizeIdFilter();
        return this.getIdsToLookup().map(function (id) {
            var model = _this.state.data[id];
            return model instanceof Model ? model : _this.hydrate(model);
        });
    };
    /**
     * Check whether if id filters should on select. If not, clear out id filter.
     */
    Query.prototype.finalizeIdFilter = function () {
        if (!this.cancelIdFilter || this.idFilter === null) {
            return;
        }
        this.where(this.model.primaryKey, Array.from(this.idFilter.values()));
        this.idFilter = null;
    };
    /**
     * Get a list of id that should be used to lookup when fetching records
     * from the state.
     */
    Query.prototype.getIdsToLookup = function () {
        var _this = this;
        // If both id filter and joined id filter are set, intersect them.
        if (this.idFilter && this.joinedIdFilter) {
            return Array.from(this.idFilter.values()).filter(function (id) {
                return _this.joinedIdFilter.has(id);
            });
        }
        // If only either one is set, return which one is set.
        if (this.idFilter || this.joinedIdFilter) {
            return Array.from((this.idFilter || this.joinedIdFilter).values());
        }
        // If none is set, return all keys.
        return Object.keys(this.state.data);
    };
    /**
     * Process the query and filter data.
     */
    Query.prototype.select = function () {
        // At first, well apply any `has` condition to the query.
        Rollcaller.applyConstraints(this);
        // Next, get all record as an array and then start filtering it through.
        var records = this.records();
        // Process `beforeProcess` hook.
        records = this.hook.executeSelectHook('beforeSelect', records);
        // Let's filter the records at first by the where clauses.
        records = this.filterWhere(records);
        // Process `afterWhere` hook.
        records = this.hook.executeSelectHook('afterWhere', records);
        // Next, lets sort the data.
        records = this.filterOrderBy(records);
        // Process `afterOrderBy` hook.
        records = this.hook.executeSelectHook('afterOrderBy', records);
        // Finally, slice the record by limit and offset.
        records = this.filterLimit(records);
        // Process `afterLimit` hook.
        records = this.hook.executeSelectHook('afterLimit', records);
        return records; // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Filter the given data by registered where clause.
     */
    Query.prototype.filterWhere = function (records) {
        return Filter.where(this, records);
    };
    /**
     * Sort the given data by registered orders.
     */
    Query.prototype.filterOrderBy = function (records) {
        return Filter.orderBy(this, records);
    };
    /**
     * Limit the given records by the lmilt and offset.
     */
    Query.prototype.filterLimit = function (records) {
        return Filter.limit(this, records);
    };
    /**
     * Get the count of the retrieved data.
     */
    Query.prototype.count = function () {
        return this.get().length;
    };
    /**
     * Get the max value of the specified filed.
     */
    Query.prototype.max = function (field) {
        var numbers = this.get().reduce(function (numbers, item) {
            if (typeof item[field] === 'number') {
                numbers.push(item[field]);
            }
            return numbers;
        }, []);
        return numbers.length === 0 ? 0 : Math.max.apply(Math, numbers);
    };
    /**
     * Get the min value of the specified filed.
     */
    Query.prototype.min = function (field) {
        var numbers = this.get().reduce(function (numbers, item) {
            if (typeof item[field] === 'number') {
                numbers.push(item[field]);
            }
            return numbers;
        }, []);
        return numbers.length === 0 ? 0 : Math.min.apply(Math, numbers);
    };
    /**
     * Get the sum value of the specified filed.
     */
    Query.prototype.sum = function (field) {
        return this.get().reduce(function (sum, item) {
            if (typeof item[field] === 'number') {
                sum += item[field];
            }
            return sum;
        }, 0);
    };
    /**
     * Create a item from given record.
     */
    Query.prototype.item = function (item) {
        if (!item) {
            return null;
        }
        if (Object.keys(this.load).length > 0) {
            item = new this.model(item);
            var items = this.hook.executeSelectHook('beforeRelations', [item]);
            item = items[0];
            Loader.eagerLoadRelations(this, [item]);
            items = this.hook.executeSelectHook('afterRelations', [item]);
            item = items[0];
        }
        return item;
    };
    /**
     * Create a collection (array) from given records.
     */
    Query.prototype.collect = function (collection) {
        var _this = this;
        if (collection.length < 1) {
            return [];
        }
        if (Object.keys(this.load).length > 0) {
            collection = collection.map(function (item) { return new _this.model(item); });
            collection = this.hook.executeSelectHook('beforeRelations', collection);
            Loader.eagerLoadRelations(this, collection);
            collection = this.hook.executeSelectHook('afterRelations', collection);
        }
        return collection;
    };
    /**
     * Create new data with all fields filled by default values.
     */
    Query.prototype.new = function () {
        var record = (new this.model()).$toJson();
        var result = this.insert(record, {});
        return result[this.entity][0];
    };
    /**
     * Save given data to the store by replacing all existing records in the
     * store. If you want to save data without replacing existing records,
     * use the `insert` method instead.
     */
    Query.prototype.create = function (data, options) {
        return this.persist(data, 'create', options); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Create records to the state.
     */
    Query.prototype.createMany = function (records) {
        var _this = this;
        var instances = this.hydrateMany(records);
        this.commit('create', instances, function () {
            _this.state.data = instances;
        });
        return this.map(instances); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Insert given data to the state. Unlike `create`, this method will not
     * remove existing data within the state, but it will update the data
     * with the same primary key.
     */
    Query.prototype.insert = function (data, options) {
        return this.persist(data, 'insert', options); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Insert list of records in the state.
     */
    Query.prototype.insertMany = function (records) {
        var _this = this;
        var instances = this.hydrateMany(records);
        this.commit('create', instances, function () {
            _this.state.data = tslib_1.__assign({}, _this.state.data, instances);
        });
        return this.map(instances); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Update data in the state.
     */
    Query.prototype.update = function (data, condition, options) {
        // If the data is array, simply normalize the data and update them.
        if (Array.isArray(data)) {
            return this.persist(data, 'update', options);
        }
        // OK, the data is not an array. Now let's check `data` to see what we can
        // do if it's a closure.
        if (typeof data === 'function') {
            // If the data is closure, but if there's no condition, we wouldn't know
            // what record to update so raise an error and abort.
            if (!condition) {
                throw new Error('You must specify `where` to update records by specifying `data` as a closure.');
            }
            // If the condition is a closure, then update records by the closure.
            if (typeof condition === 'function') {
                return this.updateByCondition(data, condition);
            }
            // Else the condition is either String or Number, so let's
            // update the record by ID.
            return this.updateById(data, condition);
        }
        // Now the data is not a closure, and it's not an array, so it should be an object.
        // If the condition is closure, we can't normalize the data so let's update
        // records using the closure.
        if (typeof condition === 'function') {
            return this.updateByCondition(data, condition);
        }
        // If there's no condition, let's normalize the data and update them.
        if (!condition) {
            return this.persist(data, 'update', options);
        }
        // Now since the condition is either String or Number, let's check if the
        // model's primary key is not a composite key. If yes, we can't set the
        // condition as ID value for the record so throw an error and abort.
        if (Array.isArray(this.model.primaryKey)) {
            throw new Error("\n        You can't specify `where` value as `string` or `number` when you\n        have a composite key defined in your model. Please include composite\n        keys to the `data` fields.\n      ");
        }
        // Finally, let's add condition as the primary key of the object and
        // then normalize them to update the records.
        return this.updateById(data, condition);
    };
    /**
     * Update all records.
     */
    Query.prototype.updateMany = function (records) {
        var instances = this.combine(records);
        return this.commitUpdate(instances); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Update the state by id.
     */
    Query.prototype.updateById = function (data, id) {
        var _a;
        id = typeof id === 'number' ? id.toString() : id;
        var instance = this.state.data[id];
        if (!instance) {
            return null;
        }
        var instances = (_a = {},
            _a[id] = this.processUpdate(data, instance),
            _a);
        this.commitUpdate(instances);
        return instances[id];
    };
    /**
     * Update the state by condition.
     */
    Query.prototype.updateByCondition = function (data, condition) {
        var _this = this;
        var instances = Object.keys(this.state.data).reduce(function (instances, id) {
            var instance = _this.state.data[id];
            if (!condition(instance)) {
                return instances;
            }
            instances[id] = _this.processUpdate(data, instance);
            return instances;
        }, {});
        return this.commitUpdate(instances);
    };
    /**
     * Update the given record with given data.
     */
    Query.prototype.processUpdate = function (data, instance) {
        if (typeof data === 'function') {
            data(instance);
            return instance;
        }
        return this.hydrate(tslib_1.__assign({}, instance, data));
    };
    /**
     * Commit `update` to the state.
     */
    Query.prototype.commitUpdate = function (instances) {
        var _this = this;
        instances = this.updateIndexes(instances);
        this.commit('update', instances, function () {
            _this.state.data = tslib_1.__assign({}, _this.state.data, instances);
        });
        return this.map(instances);
    };
    /**
     * Update the key of the instances. This is needed when a user updates
     * record's primary key. We must then update the index key to
     * correspond with new id value.
     */
    Query.prototype.updateIndexes = function (instances) {
        var _this = this;
        return Object.keys(instances).reduce(function (instances, key) {
            var instance = instances[key];
            var id = String(_this.model.id(instance));
            if (key !== id) {
                instance.$id = id;
                instances[id] = instance;
                delete instances[key];
            }
            return instances;
        }, instances);
    };
    /**
     * Insert or update given data to the state. Unlike `insert`, this method
     * will not replace existing data within the state, but it will update only
     * the submitted data with the same primary key.
     */
    Query.prototype.insertOrUpdate = function (data, options) {
        return this.persist(data, 'insertOrUpdate', options); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Insert or update the records.
     */
    Query.prototype.insertOrUpdateMany = function (records) {
        var _this = this;
        var toBeInserted = {};
        var toBeUpdated = {};
        Object.keys(records).forEach(function (id) {
            var record = records[id];
            if (_this.state.data[id]) {
                toBeUpdated[id] = record;
                return;
            }
            toBeInserted[id] = record;
        });
        return this.insertMany(toBeInserted).concat(this.updateMany(toBeUpdated));
    };
    /**
     * Persist data into the state.
     */
    Query.prototype.persist = function (data, method, options) {
        var _this = this;
        data = this.normalize(data);
        if (Utils.isEmpty(data)) {
            if (method === 'create') {
                this.state.data = {};
            }
            return {};
        }
        return Object.keys(data).reduce(function (collection, entity) {
            var query = _this.newQuery(entity);
            var persistMethod = _this.getPersistMethod(entity, method, options);
            var records = query[persistMethod + "Many"](data[entity]);
            if (records.length > 0) {
                collection[entity] = records;
            }
            return collection;
        }, {});
    };
    /**
     * Get method for the persist.
     */
    Query.prototype.getPersistMethod = function (entity, method, options) {
        if (options.create && options.create.includes(entity)) {
            return 'create';
        }
        if (options.insert && options.insert.includes(entity)) {
            return 'insert';
        }
        if (options.update && options.update.includes(entity)) {
            return 'update';
        }
        if (options.insertOrUpdate && options.insertOrUpdate.includes(entity)) {
            return 'insertOrUpdate';
        }
        return method;
    };
    /**
     * Delete records from the state.
     */
    Query.prototype.delete = function (condition) {
        if (typeof condition === 'function') {
            return this.deleteByCondition(condition);
        }
        return this.deleteById(condition);
    };
    /**
     * Delete a record by id.
     */
    Query.prototype.deleteById = function (id) {
        var _a;
        id = typeof id === 'number' ? id.toString() : id;
        var instance = this.state.data[id];
        if (!instance) {
            return null;
        }
        var instances = (_a = {}, _a[id] = instance, _a);
        var collection = this.commitDelete(instances);
        return collection[0]; // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Delete record by condition.
     */
    Query.prototype.deleteByCondition = function (condition) {
        var _this = this;
        var instances = Object.keys(this.state.data).reduce(function (records, id) {
            var instance = _this.state.data[id];
            if (!condition(instance)) {
                return records;
            }
            records[id] = instance;
            return records;
        }, {});
        return this.commitDelete(instances); // TODO: Delete "as ..." when model type coverage reaches 100%.
    };
    /**
     * Delete all records from the state.
     */
    Query.prototype.deleteAll = function () {
        var instances = this.state.data;
        this.commitDelete(instances);
    };
    /**
     * Commit `delete` to the state.
     */
    Query.prototype.commitDelete = function (instances) {
        var _this = this;
        this.commit('delete', instances, function () {
            var ids = Object.keys(instances);
            _this.state.data = Object.keys(_this.state.data).reduce(function (instances, id) {
                if (!ids.includes(id)) {
                    instances[id] = _this.state.data[id];
                }
                return instances;
            }, {});
        });
        return this.map(instances);
    };
    /**
     * Normalize the given data.
     */
    Query.prototype.normalize = function (data) {
        return Processor.normalize(this, data);
    };
    /**
     * Convert given record to the model instance.
     */
    Query.prototype.hydrate = function (record) {
        var model = this.model;
        return new model(record);
    };
    /**
     * Convert all given records to model instances.
     */
    Query.prototype.hydrateMany = function (records) {
        var _this = this;
        return Object.keys(records).reduce(function (instances, id) {
            var record = records[id];
            instances[id] = _this.hydrate(record);
            return instances;
        }, {});
    };
    /**
     * Convert given records to instances by merging existing record. If there's
     * no existing record, that record will not be included in the result.
     */
    Query.prototype.combine = function (records) {
        var _this = this;
        return Object.keys(records).reduce(function (instances, id) {
            var instance = _this.state.data[id];
            if (!instance) {
                return instances;
            }
            var record = records[id];
            instances[id] = _this.hydrate(tslib_1.__assign({}, instance, record));
            return instances;
        }, {});
    };
    /**
     * Convert all given instances to collections.
     */
    Query.prototype.map = function (instances) {
        return Object.keys(instances).map(function (id) { return instances[id]; });
    };
    /**
     * Execute given callback by executing before and after hooks of the specified
     * method to the given instances. The method name should be something like
     * `create` or `update`, then it will be converted to `beforeCreate` ,
     * `afterCreate` and so on.
     */
    Query.prototype.commit = function (method, instances, callback) {
        var name = "" + method.charAt(0).toUpperCase() + method.slice(1);
        this.hook.executeMutationHookOnRecords("before" + name, instances);
        callback();
        this.hook.executeMutationHookOnRecords("after" + name, instances);
    };
    return Query;
}());
export default Query;
//# sourceMappingURL=Query.js.map