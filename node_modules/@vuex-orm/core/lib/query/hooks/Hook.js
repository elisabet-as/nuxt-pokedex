var Hook = /** @class */ (function () {
    /**
     * Create a lidecycle hook instance.
     */
    function Hook(query) {
        /**
         * The global hook index to be deleted.
         */
        this.indexToBeDeleted = [];
        this.query = query;
    }
    /**
     * Register a callback. It Returns unique ID for registered callback.
     */
    Hook.on = function (on, callback, once) {
        if (once === void 0) { once = false; }
        var uid = this.lastHookId + 1;
        this.lastHookId = uid;
        if (!this.hooks[on]) {
            this.hooks[on] = [];
        }
        this.hooks[on].push({ callback: callback, once: once, uid: uid });
        return uid;
    };
    /**
     * Remove hook registration.
     */
    Hook.off = function (uid) {
        var _this = this;
        var removed = false;
        Object.keys(this.hooks).some(function (on) {
            var hook = _this.hooks[on];
            var index = hook.findIndex(function (h) { return h.uid === uid; });
            if (index !== -1) {
                hook.splice(index, 1);
                removed = true;
            }
            return removed;
        });
        return removed;
    };
    /**
     * Get the hook class.
     */
    Hook.prototype.self = function () {
        return this.constructor;
    };
    /**
     * Get the hook for the given name.
     */
    Hook.prototype.getHook = function (name) {
        var hook = this.query.model[name];
        return hook || null;
    };
    /**
     * Get the global hook.
     */
    Hook.prototype.getGlobalHook = function (name) {
        var hook = this.self().hooks[name];
        return hook || null;
    };
    /**
     * Check if the given hook exist.
     */
    Hook.prototype.has = function (name) {
        return !!this.getHook(name) || !!this.getGlobalHook(name);
    };
    /**
     * Execute select hook for the given collection.
     */
    Hook.prototype.executeSelectHook = function (on, records) {
        if (!this.has(on)) {
            return records;
        }
        records = this.executeLocalSelectHook(on, records);
        records = this.executeGlobalSelectHook(on, records);
        return records;
    };
    /**
     * Execute select hook against given records.
     */
    Hook.prototype.executeLocalSelectHook = function (on, records) {
        var hook = this.getHook(on);
        if (!hook) {
            return records;
        }
        return hook(records, this.query.entity);
    };
    /**
     * Execute the global select hook against given records.
     */
    Hook.prototype.executeGlobalSelectHook = function (on, records) {
        var _this = this;
        var hooks = this.getGlobalHook(on);
        if (!hooks) {
            return records;
        }
        // Track indexes to delete.
        var deleteHookIndexes = [];
        // Loop all hooks.
        hooks.forEach(function (hook, hookIndex) {
            var callback = hook.callback, once = hook.once;
            records = callback.call(_this.query, records, _this.query.entity);
            // Add hook index to delete.
            once && deleteHookIndexes.push(hookIndex);
        });
        // Remove hooks to be deleted in reverse order.
        deleteHookIndexes.reverse().forEach(function (hookIndex) {
            hooks.splice(hookIndex, 1);
        });
        return records;
    };
    /**
     * Execute the callback for all given records.
     */
    Hook.prototype.executeMutationHookOnRecords = function (on, records) {
        var _this = this;
        if (!this.has(on)) {
            return;
        }
        Object.keys(records).forEach(function (id) {
            var result = _this.executeMutationHook(on, records[id]);
            if (result === false) {
                delete records[id];
            }
        });
        this.removeGlobalHook(on);
    };
    /**
     * Execute mutation hook against given model.
     */
    Hook.prototype.executeMutationHook = function (on, model) {
        if (this.executeLocalMutationHook(on, model) === false) {
            return false;
        }
        if (this.executeGlobalMutationHook(on, model) === false) {
            return false;
        }
    };
    /**
     * Execute the local mutation hook.
     */
    Hook.prototype.executeLocalMutationHook = function (on, model) {
        var hook = this.getHook(on);
        if (!hook) {
            return;
        }
        return hook(model, this.query.entity);
    };
    /**
     * Execute the global mutation hook.
     */
    Hook.prototype.executeGlobalMutationHook = function (on, model) {
        var _this = this;
        var hooks = this.getGlobalHook(on);
        if (!hooks) {
            return;
        }
        // Track results.
        var results = [];
        // Loop all hooks.
        hooks.forEach(function (hook, index) {
            results.push(hook.callback.call(_this.query, model, _this.query.entity));
            // Add hook index to delete.
            hook.once && _this.indexToBeDeleted.push(index);
        });
        if (results.includes(false)) {
            return false;
        }
    };
    /**
     * Remove global hooks which are executed and defined as once.
     */
    Hook.prototype.removeGlobalHook = function (on) {
        var hooks = this.getGlobalHook(on);
        if (!hooks) {
            return;
        }
        this.indexToBeDeleted.reverse().forEach(function (index) { hooks.splice(index, 1); });
    };
    /**
     * Global lifecycle hooks for the query.
     */
    Hook.hooks = {};
    /**
     * Hook UID counter.
     */
    Hook.lastHookId = 0;
    return Hook;
}());
export default Hook;
//# sourceMappingURL=Hook.js.map