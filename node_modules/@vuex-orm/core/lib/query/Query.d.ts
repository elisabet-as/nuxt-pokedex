import * as Vuex from 'vuex';
import Database from '../database/Database';
import Models from '../database/Models';
import Modules from '../database/Modules';
import * as Data from '../data';
import Model from '../model/Model';
import State from '../modules/contracts/State';
import RootState from '../modules/contracts/RootState';
import PersistOptions from '../modules/payloads/PersistOptions';
import * as Contracts from './contracts';
import * as Options from './options';
import Hook from './hooks/Hook';
export declare type UpdateClosure = (record: Data.Record) => void;
export declare type Predicate = (item: Data.Record) => boolean;
export declare type UpdateCondition = number | string | Predicate | null;
export declare type DeleteCondition = number | string | Predicate;
export declare type Buildable = Data.Record | Data.Record[] | null;
export declare type Constraint = (query: Query) => void | boolean;
export declare type ConstraintCallback = (relationName: string) => Constraint | null;
export default class Query<T extends Model = Model> {
    /**
     * The root state of the Vuex Store.
     */
    rootState: RootState;
    /**
     * The entity state of the Vuex Store.
     */
    state: State;
    /**
     * The entity name being queried.
     */
    entity: string;
    /**
     * The model being queried.
     */
    model: typeof Model;
    /**
     * The module being queried.
     */
    module: Vuex.Module<State, any>;
    /**
     * Primary key ids to filter records by. It is used for filtering records
     * direct key lookup when a user is trying to fetch records by its
     * primary key.
     *
     * It should not be used if there is a logic which prevents index usage, for
     * example, an "or" condition which already requires a full scan of records.
     */
    idFilter: Set<number | string> | null;
    /**
     * Whether to use `idFilter` key lookup. True if there is a logic which
     * prevents index usage, for example, an "or" condition which already
     * requires full scan.
     */
    cancelIdFilter: Boolean;
    /**
     * Primary key ids to filter joined records. It is used for filtering
     * records direct key lookup. It should not be cancelled, because it
     * is free from the effects of normal where methods.
     */
    joinedIdFilter: Set<number | string> | null;
    /**
     * The where constraints for the query.
     */
    wheres: Options.Where[];
    /**
     * The has constraints for the query.
     */
    have: Options.Has[];
    /**
     * The orders of the query result.
     */
    orders: Options.Orders[];
    /**
     * Number of results to skip.
     */
    offsetNumber: number;
    /**
     * Maximum number of records to return.
     *
     * We use polyfill of `Number.MAX_SAFE_INTEGER` for IE11 here.
     */
    limitNumber: number;
    /**
     * The relationships that should be eager loaded with the result.
     */
    load: Options.Load;
    /**
     * The lifecycle hook instance.
     */
    hook: Hook;
    /**
     * Create a new Query instance.
     */
    constructor(state: RootState, entity: string);
    /**
     * Get the database from the container.
     */
    static database(): Database;
    /**
     * Get model of given name from the container.
     */
    static getModel(name: string): typeof Model;
    /**
     * Get all models from the container.
     */
    static getModels(): Models;
    /**
     * Get module of given name from the container.
     */
    static getModule(name: string): Vuex.Module<State, any>;
    /**
     * Get all modules from the container.
     */
    static getModules(): Modules;
    /**
     * Delete all records from the state.
     */
    static deleteAll(state: RootState): void;
    /**
     * Register a callback. It Returns unique ID for registered callback.
     */
    static on(on: string, callback: Function, once?: boolean): number;
    /**
     * Remove hook registration.
     */
    static off(uid: number): boolean;
    /**
     * Get query class.
     */
    self(): typeof Query;
    /**
     * Create a new query instance.
     */
    newQuery(entity?: string): Query;
    /**
     * Get the database from the container.
     */
    database(): Database;
    /**
     * Get model of given name from the container.
     */
    getModel(name?: string): typeof Model;
    /**
     * Get all models from the container.
     */
    getModels(): Models;
    /**
     * Get module of given name from the container.
     */
    getModule(name?: string): Vuex.Module<State, any>;
    /**
     * Get all modules from the container.
     */
    getModules(): Modules;
    /**
     * Returns all record of the query chain result. This method is alias
     * of the `get` method.
     */
    all(): Data.Collection<T>;
    /**
     * Get the record of the given id.
     */
    find(id: number | string): Data.Item<T>;
    /**
     * Get the record of the given array of ids.
     */
    findIn(idList: Array<number | string>): Data.Collection<T>;
    /**
     * Returns all record of the query chain result.
     */
    get(): Data.Collection<T>;
    /**
     * Returns the first record of the query chain result.
     */
    first(): Data.Item<T>;
    /**
     * Returns the last single record of the query chain result.
     */
    last(): Data.Item<T>;
    /**
     * Add a and where clause to the query.
     */
    where(field: any, value?: any): this;
    /**
     * Add a or where clause to the query.
     */
    orWhere(field: any, value?: any): this;
    /**
     * Filter records by their primary key.
     */
    whereId(value: number | string): this;
    /**
     * Filter records by their primary keys.
     */
    whereIdIn(values: (string | number)[]): this;
    /**
     * Fast comparison for foreign keys. If the foreign key is the primary key,
     * it uses object lookup, fallback normal where otherwise.
     *
     * Why separate `whereFk` instead of just `where`? Additional logic needed
     * for the distinction between where and orWhere in normal queries, but
     * Fk lookups are always "and" type.
     */
    whereFk(field: string, value: string | number | (string | number)[]): this;
    /**
     * Check whether the given field and value combination is filterable through
     * primary key direct look up.
     */
    private isIdfilterable;
    /**
     * Set id filter for the given where condition.
     */
    private setIdFilter;
    /**
     * Set joined id filter for the given where condition.
     */
    private setJoinedIdFilter;
    /**
     * Add an order to the query.
     */
    orderBy(field: string, direction?: Options.OrderDirection): this;
    /**
     * Add an offset to the query.
     */
    offset(offset: number): this;
    /**
     * Add limit to the query.
     */
    limit(limit: number): this;
    /**
     * Set the relationships that should be loaded.
     */
    with(name: string | string[], constraint?: Contracts.RelationshipConstraint | null): this;
    /**
     * Query all relations.
     */
    withAll(): this;
    /**
     * Query all relations recursively.
     */
    withAllRecursive(depth?: number): this;
    /**
     * Set where constraint based on relationship existence.
     */
    has(relation: string, operator?: string | number, count?: number): this;
    /**
     * Set where constraint based on relationship absence.
     */
    hasNot(relation: string, operator?: string | number, count?: number): this;
    /**
     * Add where has condition.
     */
    whereHas(relation: string, constraint: Options.HasConstraint): this;
    /**
     * Add where has not condition.
     */
    whereHasNot(relation: string, constraint: Options.HasConstraint): this;
    /**
     * Get all records from the state and convert them into the array. It will
     * check if the record is an instance of Model and if not, it will
     * instantiate before returning them.
     *
     * This is needed to support SSR, that when the state is hydrated at server
     * side, it will be converted to the plain record at the client side.
     */
    records(): Data.Collection;
    /**
     * Check whether if id filters should on select. If not, clear out id filter.
     */
    private finalizeIdFilter;
    /**
     * Get a list of id that should be used to lookup when fetching records
     * from the state.
     */
    private getIdsToLookup;
    /**
     * Process the query and filter data.
     */
    select(): Data.Collection<T>;
    /**
     * Filter the given data by registered where clause.
     */
    filterWhere(records: Data.Collection): Data.Collection;
    /**
     * Sort the given data by registered orders.
     */
    filterOrderBy(records: Data.Collection): Data.Collection;
    /**
     * Limit the given records by the lmilt and offset.
     */
    filterLimit(records: Data.Collection): Data.Collection;
    /**
     * Get the count of the retrieved data.
     */
    count(): number;
    /**
     * Get the max value of the specified filed.
     */
    max(field: string): number;
    /**
     * Get the min value of the specified filed.
     */
    min(field: string): number;
    /**
     * Get the sum value of the specified filed.
     */
    sum(field: string): number;
    /**
     * Create a item from given record.
     */
    item(item?: Data.Instance): Data.Item;
    /**
     * Create a collection (array) from given records.
     */
    collect(collection: Data.Collection): Data.Collection;
    /**
     * Create new data with all fields filled by default values.
     */
    new(): Model;
    /**
     * Save given data to the store by replacing all existing records in the
     * store. If you want to save data without replacing existing records,
     * use the `insert` method instead.
     */
    create(data: Data.Record | Data.Record[], options: PersistOptions): Data.Collections<T>;
    /**
     * Create records to the state.
     */
    createMany(records: Data.Records): Data.Collection<T>;
    /**
     * Insert given data to the state. Unlike `create`, this method will not
     * remove existing data within the state, but it will update the data
     * with the same primary key.
     */
    insert(data: Data.Record | Data.Record[], options: PersistOptions): Data.Collections<T>;
    /**
     * Insert list of records in the state.
     */
    insertMany(records: Data.Records): Data.Collection<T>;
    /**
     * Update data in the state.
     */
    update(data: Data.Record | Data.Record[] | UpdateClosure, condition: UpdateCondition, options: PersistOptions): Data.Item<T> | Data.Collection<T> | Data.Collections<T>;
    /**
     * Update all records.
     */
    updateMany(records: Data.Records): Data.Collection<T>;
    /**
     * Update the state by id.
     */
    updateById(data: Data.Record | UpdateClosure, id: string | number): Data.Item<T>;
    /**
     * Update the state by condition.
     */
    updateByCondition(data: Data.Record | UpdateClosure, condition: Predicate): Data.Collection<T>;
    /**
     * Update the given record with given data.
     */
    processUpdate(data: Data.Record | UpdateClosure, instance: Data.Instance): Data.Instance;
    /**
     * Commit `update` to the state.
     */
    commitUpdate(instances: Data.Instances): Data.Collection;
    /**
     * Update the key of the instances. This is needed when a user updates
     * record's primary key. We must then update the index key to
     * correspond with new id value.
     */
    private updateIndexes;
    /**
     * Insert or update given data to the state. Unlike `insert`, this method
     * will not replace existing data within the state, but it will update only
     * the submitted data with the same primary key.
     */
    insertOrUpdate(data: Data.Record | Data.Record[], options: PersistOptions): Data.Collections<T>;
    /**
     * Insert or update the records.
     */
    insertOrUpdateMany(records: Data.Records): Data.Collection<T>;
    /**
     * Persist data into the state.
     */
    persist(data: Data.Record | Data.Record[], method: string, options: PersistOptions): Data.Collections;
    /**
     * Get method for the persist.
     */
    getPersistMethod(entity: string, method: string, options: PersistOptions): string;
    /**
     * Delete records from the state.
     */
    delete(condition: DeleteCondition): Data.Item<T> | Data.Collection<T>;
    /**
     * Delete a record by id.
     */
    deleteById(id: string | number): Data.Item<T>;
    /**
     * Delete record by condition.
     */
    deleteByCondition(condition: Predicate): Data.Collection<T>;
    /**
     * Delete all records from the state.
     */
    deleteAll(): void;
    /**
     * Commit `delete` to the state.
     */
    commitDelete(instances: Data.Instances): Data.Collection;
    /**
     * Normalize the given data.
     */
    normalize(data: Data.Record | Data.Record[]): Data.NormalizedData;
    /**
     * Convert given record to the model instance.
     */
    hydrate(record: Data.Record): Data.Instance;
    /**
     * Convert all given records to model instances.
     */
    hydrateMany(records: Data.Records): Data.Instances;
    /**
     * Convert given records to instances by merging existing record. If there's
     * no existing record, that record will not be included in the result.
     */
    combine(records: Data.Records): Data.Instances;
    /**
     * Convert all given instances to collections.
     */
    map(instances: Data.Instances): Data.Collection;
    /**
     * Execute given callback by executing before and after hooks of the specified
     * method to the given instances. The method name should be something like
     * `create` or `update`, then it will be converted to `beforeCreate` ,
     * `afterCreate` and so on.
     */
    commit(method: string, instances: Data.Instances, callback: Function): void;
}
